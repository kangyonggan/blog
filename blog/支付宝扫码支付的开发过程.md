---
title: 支付宝扫码支付的开发过程
date: 2018-10-29 16:23:01
categories: Java后台
tags:
- Java
---


## 名词定义
- 用户：在我们网站上交易的客户。
- 支付网关：是我们商户和支付宝开放平台对接的系统。
- 商户系统：充值成功后用于发货的系统。
- 微信支付平台：是阿里的支付宝开放。

## 支付宝扫码支付官网地址
支付接口：[https://docs.open.alipay.com/api_1/](https://docs.open.alipay.com/api_1/)

<!-- more -->

## 序列图
用户登录我们的网站，选择好商品之后，点击使用微信扫码付款，直到用户户看到付款成功。对应的序列图如下：
![](/upload/article/alipay-seq.png)

我们就是要做上图这么一件事，下面是详细的开发步骤。

## 一、注册
注册地址：[https://memberprod.alipay.com/account/reg/index.htm](https://memberprod.alipay.com/account/reg/index.htm)

> 只有企业账户才能玩支付。

## 二、配置
登录微信公共号，获取如下三项配置：
1. 应用ID - 支付宝分配给开发者的应用ID
2. 商户私钥 - 商户自己生成一对密钥中的私钥
3. 支付宝公钥 - 登录开放平台后自行下载

生成RSA密钥：[https://docs.open.alipay.com/291/105971/](https://docs.open.alipay.com/291/105971/)
上传商户公钥并获取支付宝公钥：[https://docs.open.alipay.com/291/105972/](https://docs.open.alipay.com/291/105972/)
使用私商户钥生成请求签名：[https://docs.open.alipay.com/291/105974/](https://docs.open.alipay.com/291/105974/)
使用支付宝公钥验签

## 三、统一收单线下交易预创建（下单）
这是一个预交易接口，即调用后不会真正的发生金钱交易，只是告诉支付宝有个用户一会要支付1000元买手机，你给我生成一个支付链接，我把这个链接变成二维码，让他使用支付宝来扫描。调用此接口后会返回支付链接。

```
/**
 * 支付宝（预）支付
 *
 * @param command
 * @return
 */
public CommonResponse pay(Command command) {
    log.info("进入支付宝预支付接口");
    PayResponse payResponse = PayResponse.getResponse();

    try {
        Map<String, String> bizContent = new HashMap<>(8);
        bizContent.put("out_trade_no", command.getSerialNo());
        bizContent.put("total_amount", command.getAmount().setScale(2, BigDecimal.ROUND_HALF_UP).toString());
        bizContent.put("subject", "CK充值中心-充值");

        AlipayClient alipayClient = new DefaultAlipayClient(apiUrl, appId, privateKey, "json", "utf-8", publicKey, "RSA2");
        AlipayTradePrecreateRequest request = new AlipayTradePrecreateRequest();
        request.setNotifyUrl(notifyUrl);
        request.setBizContent(JSON.toJSONString(bizContent));
        AlipayTradePrecreateResponse response = alipayClient.execute(request);
        if (response.isSuccess()) {
            log.info("获取二维码成功");

            String qrName = command.getSerialNo() + ".png";
            String name = fileRootPath + "qrcode/" + qrName;

            BufferedImage image = QRCodeKit.createQRCodeWithLogo(response.getQrCode(), new File(fileRootPath + "qrcode/logo.png"));
            ImageIO.write(image, "png", new File(name));

            log.info("二维码生成成功，路径： {}", name);

            payResponse.setApiUrl("upload/qrcode/" + qrName);
        } else {
            log.info("获取二维码失败");
        }

        payResponse.setRespCo(response.getCode());
        payResponse.setRespMsg(response.getMsg());
        payResponse.setRespData(response.getBody());
    } catch (Exception e) {
        throw new SendException("请求支付宝预支付接口异常", e);
    }

    log.info("离开支付宝预支付接口");
    return payResponse;
}
```

其中Alipay开头的是阿里的sdk，使用maven依赖如下：
```
<dependency>
    <groupId>com.alipay.sdk</groupId>
    <artifactId>alipay-sdk-java</artifactId>
    <version>3.3.87.ALL</version>
</dependency>
```

QRCodeKit是一个二维码生成工具：  
```

import com.google.zxing.*;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.binary.Base64OutputStream;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.HashMap;
import java.util.Map;

/**
 * @author kangyonggan
 * @since 10/29/18
 */
public class QRCodeKit {

    private static final String QRCODE_DEFAULT_CHARSET = "UTF-8";

    private static final int QRCODE_DEFAULT_HEIGHT = 300;

    private static final int QRCODE_DEFAULT_WIDTH = 300;

    private static final int BLACK = 0xFF000000;

    private static final int WHITE = 0xFFFFFFFF;

    public static void main(String[] args) throws IOException, NotFoundException {
        String data = "扫码看到我";
        File logoFile = new File("/xxx/logo.png");
        BufferedImage image = QRCodeKit.createQRCodeWithLogo(data, logoFile);
        ImageIO.write(image, "png", new File("/xxx/res.png"));
    }

    /**
     * Create qrcode with default settings
     *
     * @param data
     * @return
     */
    public static BufferedImage createQRCode(String data) {
        return createQRCode(data, QRCODE_DEFAULT_WIDTH, QRCODE_DEFAULT_HEIGHT);
    }

    /**
     * Create qrcode with default charset
     *
     * @param data
     * @param width
     * @param height
     * @return
     */
    public static BufferedImage createQRCode(String data, int width, int height) {
        return createQRCode(data, QRCODE_DEFAULT_CHARSET, width, height);
    }

    /**
     * Create qrcode with specified charset
     *
     * @param data
     * @param charset
     * @param width
     * @param height
     * @return
     */
    public static BufferedImage createQRCode(String data, String charset, int width, int height) {
        Map hint = new HashMap();
        hint.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);
        hint.put(EncodeHintType.CHARACTER_SET, charset);

        return createQRCode(data, charset, hint, width, height);
    }

    /**
     * Create qrcode with specified hint
     *
     * @param data
     * @param charset
     * @param hint
     * @param width
     * @param height
     * @return
     */
    public static BufferedImage createQRCode(String data, String charset, Map<EncodeHintType, ?> hint, int width,
                                             int height) {
        BitMatrix matrix;
        try {
            matrix = new MultiFormatWriter().encode(new String(data.getBytes(charset), charset), BarcodeFormat.QR_CODE,
                    width, height, hint);
            return toBufferedImage(matrix);
        } catch (WriterException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (Exception e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }

    public static BufferedImage toBufferedImage(BitMatrix matrix) {
        int width = matrix.getWidth();
        int height = matrix.getHeight();
        BufferedImage image = new BufferedImage(width, height,
                BufferedImage.TYPE_INT_RGB);
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                image.setRGB(x, y, matrix.get(x, y) ? BLACK : WHITE);
            }
        }
        return image;
    }

    /**
     * Create qrcode with default settings and logo
     *
     * @param data
     * @param logoFile
     * @return
     */
    public static BufferedImage createQRCodeWithLogo(String data, File logoFile) {
        return createQRCodeWithLogo(data, QRCODE_DEFAULT_WIDTH, QRCODE_DEFAULT_HEIGHT, logoFile);
    }

    /**
     * Create qrcode with default charset and logo
     *
     * @param data
     * @param width
     * @param height
     * @param logoFile
     * @return
     */
    public static BufferedImage createQRCodeWithLogo(String data, int width, int height, File logoFile) {
        return createQRCodeWithLogo(data, QRCODE_DEFAULT_CHARSET, width, height, logoFile);
    }

    /**
     * Create qrcode with specified charset and logo
     *
     * @param data
     * @param charset
     * @param width
     * @param height
     * @param logoFile
     * @return
     */
    public static BufferedImage createQRCodeWithLogo(String data, String charset, int width, int height, File logoFile) {
        Map<EncodeHintType, Object> hint = new HashMap<>(8);
        hint.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);
        hint.put(EncodeHintType.CHARACTER_SET, charset);

        return createQRCodeWithLogo(data, charset, hint, width, height, logoFile);
    }

    /**
     * Create qrcode with specified hint and logo
     *
     * @param data
     * @param charset
     * @param hint
     * @param width
     * @param height
     * @param logoFile
     * @return
     */
    public static BufferedImage createQRCodeWithLogo(String data, String charset, Map<EncodeHintType, ?> hint,
                                                     int width, int height, File logoFile) {
        try {
            BufferedImage qrcode = createQRCode(data, charset, hint, width, height);
            BufferedImage logo = ImageIO.read(logoFile);
            int deltaHeight = height - logo.getHeight();
            int deltaWidth = width - logo.getWidth();

            BufferedImage combined = new BufferedImage(height, width, BufferedImage.TYPE_INT_ARGB);
            Graphics2D g = (Graphics2D) combined.getGraphics();
            g.drawImage(qrcode, 0, 0, null);
            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1f));
            g.drawImage(logo, Math.round(deltaWidth / 2), Math.round(deltaHeight / 2), null);

            return combined;
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (Exception e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }

    /**
     * Return base64 for image
     *
     * @param image
     * @return
     */
    public static String getImageBase64String(BufferedImage image) {
        String result = null;
        try {
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            OutputStream b64 = new Base64OutputStream(os);
            ImageIO.write(image, "png", b64);
            result = os.toString("UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
        return result;
    }

    /**
     * Decode the base64Image data to image
     *
     * @param base64ImageString
     * @param file
     */
    public static void convertBase64StringToImage(String base64ImageString, File file) {
        FileOutputStream os;
        try {
            Base64 d = new Base64();
            byte[] bs = d.decode(base64ImageString);
            os = new FileOutputStream(file.getAbsolutePath());
            os.write(bs);
            os.close();
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (Exception e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }


}
```

生成二维码使用的是zxing:  
```
<dependency>
    <groupId>com.google.zxing</groupId>
    <artifactId>core</artifactId>
    <version>3.3.0</version>
</dependency>
<dependency>
    <groupId>com.google.zxing</groupId>
    <artifactId>javase</artifactId>
    <version>3.3.0</version>
</dependency>
```

对应接口文档地址：[https://docs.open.alipay.com/api_1/alipay.trade.precreate](https://docs.open.alipay.com/api_1/alipay.trade.precreate)

## 四、后台通知
当用户扫码完成支付后，微信会发起后台通知告诉我们交易成功了。

```
/**
 * 支付宝后台通知
 *
 * @param request
 * @return
 * @throws Exception
 */
@PostMapping("alipay")
public String alipay(HttpServletRequest request) throws Exception {
    Map<String, String> maps = new HashMap<>(16);
    Map requestParams = request.getParameterMap();
    for (Iterator iter = requestParams.keySet().iterator(); iter.hasNext(); ) {
        String name = (String) iter.next();
        String[] values = (String[]) requestParams.get(name);
        String valueStr = "";
        for (int i = 0; i < values.length; i++) {
            valueStr = (i == values.length - 1) ? valueStr + values[i] : valueStr + values[i] + ",";
        }
        maps.put(name, valueStr);
    }
    log.info("支付宝后台通知内容:{}", maps);

    // 验签
    boolean signVerified = AlipaySignature.rsaCheckV1(maps, aliPubKey, "UTF-8", "RSA2");
    if (signVerified) {
        log.info("验签通过");

        String serialNo = maps.get("out_trade_no");
        Command command = commandService.findCommandBySerialNo(serialNo);
        if (command == null) {
            log.info("异步通知流水号不存在:{}", serialNo);
            return "false";
        }

        if ("TRADE_SUCCESS".equals(maps.get("trade_status")) && !"YF".contains(command.getTranCo())) {
            log.info("交易成功，通知商户发货");
            // 通知商户发货
            if(paymentHelper.notify(command)) {
                // 响应落库, 更新交易状态
                aliPayTransactionService.processNotice(maps, command);
            }
        }
    } else {
        log.info("验签失败");
        return "failure";
    }

    return "success";
}
```

对应的接口文档：[https://docs.open.alipay.com/api_1/alipay.trade.precreate/](https://docs.open.alipay.com/api_1/alipay.trade.precreate/)

> 在文档的最后一行。

## 五、单笔查询
如果我们没收到后台通知怎么办？这时候就可以通过单笔查询主动去支付宝开放平台查询订单状态。

```
Map<String, String> bizContent = new HashMap<>(4);
bizContent.put("out_trade_no", command.getSerialNo());

AlipayClient alipayClient = new DefaultAlipayClient(apiUrl, appId, privateKey, "json", "utf-8", publicKey, "RSA2");
AlipayTradeQueryRequest request = new AlipayTradeQueryRequest();
request.setBizContent(JSON.toJSONString(bizContent));
AlipayTradeQueryResponse response = alipayClient.execute(request);
log.info("查询的响应:{}", response.getBody());

String respCo = response.getCode();
String respMsg = response.getMsg();
String tranSt = TranSt.I.getCode();
String amt = response.getBuyerPayAmount();
BigDecimal amount = new BigDecimal(StringUtils.isEmpty(amt) ? "0" : amt);
String channelSerialNo = response.getTradeNo();

if (response.isSuccess()) {
    log.info("查询得到结果");

    String tradeStatus = response.getTradeStatus();
    log.info("交易状态:{}", tradeStatus);
    if ("TRADE_SUCCESS".equals(tradeStatus)) {
        tranSt = TranSt.Y.getCode();
    }
} else {
    log.info("查询失败");
}
log.info("查询到的交易:{}, 交易结果:{}", command.getSerialNo(), tranSt);
```

对应接口文档地址：[https://docs.open.alipay.com/api_1/alipay.trade.query/](https://docs.open.alipay.com/api_1/alipay.trade.query/)

## 六、下载对账单
如果我们需要日终对账，那么就要用到下载对账单接口。但是此接口不大符合我的需要，因此我没用这个接口，而是循环使用单笔查询代替的。
