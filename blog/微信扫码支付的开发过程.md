---
title: 微信扫码支付的开发过程
date: 2018-10-29 15:25:20
categories: Java后台
tags:
- Java
---


## 名词定义
- 用户：在我们网站上交易的客户。
- 支付网关：是我们商户和微信支付平台对接的系统。
- 商户系统：充值成功后用于发货的系统。
- 微信支付平台：是腾讯的微信支付平台。

## 微信支付官网地址
扫码支付介绍：[https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_1](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=6_1)

<!-- more -->

## 序列图
用户登录我们的网站，选择好商品之后，点击使用微信扫码付款，直到用户户看到付款成功。对应的序列图如下：
![](/upload/article/wxpay-flow.png)

我们就是要做上图这么一件事，下面是详细的开发步骤。

## 一、注册
注册地址：[https://mp.weixin.qq.com/cgi-bin/registermidpage?action=index&lang=zh_CN&token=](https://mp.weixin.qq.com/cgi-bin/registermidpage?action=index&lang=zh_CN&token=)

> 只有企业才能进行微信认证，只有进行了认证才能玩微信支付。

## 二、配置
登录微信公共号，获取如下三项配置：
1. 公众账号ID - 微信支付分配的公众账号ID
2. 商户号 - 微信支付分配的商户号
3. key - key设置路径：微信商户平台(pay.weixin.qq.com)-->账户设置-->API安全-->密钥设置

## 三、预交易（统一下单）
这是一个预交易接口，即调用后不会真正的发生金钱交易，只是告诉微信有个用户一会要支付1000元买手机，你给我生成一个支付链接，我把这个链接变成二维码，让他使用微信来扫描。调用此接口后会返回支付链接。

```
/**
 * 微信（预）支付
 *
 * @param command
 * @return
 */
public CommonResponse pay(Command command) {
    log.info("进入微信支付接口");
    PayResponse payResponse = PayResponse.getResponse();

    try {
        WXPay wxpay = new WXPay(wxPayConfig);

        Map<String, String> data = new HashMap<>(16);
        data.put("body", "XX充值中心-充值");
        data.put("out_trade_no", command.getSerialNo());
        data.put("fee_type", "CNY");
        data.put("total_fee", String.valueOf(command.getAmount().multiply(BigDecimal.valueOf(100)).toBigInteger()));
        data.put("spbill_create_ip", command.getClientIp());
        data.put("notify_url", notifyUrl);
        data.put("trade_type", "NATIVE");
        data.put("product_id", command.getProductCo());

        Map<String, String> resp = wxpay.unifiedOrder(data);
        String respCo = resp.get("return_code");
        String respMsg = resp.get("return_msg");
        log.info("微信支付响应码:{}", respCo);
        log.info("微信支付响应消息:{}", respMsg);
        if (WXPayConstants.SUCCESS.equals(respCo)) {
            String codeUrl = resp.get("code_url");
            String prepayId = resp.get("prepay_id");
            log.info("微信支付获取二维码成功：{}", codeUrl);

            String qrName = command.getSerialNo() + ".png";
            String name = fileRootPath + "qrcode/" + qrName;

            BufferedImage image = QRCodeKit.createQRCodeWithLogo(codeUrl, new File(fileRootPath + "qrcode/logo.png"));
            ImageIO.write(image, "png", new File(name));

            log.info("二维码生成成功，路径： {}", name);

            payResponse.setApiUrl("upload/qrcode/" + qrName);
            payResponse.setChannelSerialNo(prepayId);
        }

        payResponse.setRespCo(respCo);
        payResponse.setRespMsg(respMsg);
        payResponse.setRespData(resp.toString());
    } catch (Exception e) {
        throw new SendException("请求微信支付接口异常", e);
    }

    log.info("离开微信支付接口");
    return payResponse;
}
```

wxPayConfig是微信支付配置，代码如下：
```

import demo.sdk.IWXPayDomain;
import demo.sdk.WXPayConfig;
import lombok.extern.log4j.Log4j2;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.io.InputStream;

/**
 * @author kangyonggan
 * @since 10/9/18
 */
@Log4j2
@Component
public class MyWXPayConfig extends WXPayConfig {

    @Value("${wxpay.appid}")
    private String appId;

    @Value("${wxpay.mchid}")
    private String mchId;

    @Value("${wxpay.key}")
    private String key;

    @Value("${wxpay.domain}")
    private String domain;

    @Override
    public String getAppID() {
        return appId;
    }

    @Override
    public String getMchID() {
        return mchId;
    }

    @Override
    public String getKey() {
        return key;
    }

    @Override
    public InputStream getCertStream() {
        return null;
    }

    @Override
    public IWXPayDomain getWXPayDomain() {
        IWXPayDomain iwxPayDomain = new IWXPayDomain() {
            @Override
            public void report(String domain, long elapsedTimeMillis, Exception ex) {
                log.error("微信支付域名:{}, {}", domain, elapsedTimeMillis, ex);
            }

            @Override
            public DomainInfo getDomain(WXPayConfig config) {
                return new DomainInfo(domain, true);
            }
        };
        return iwxPayDomain;
    }

}
```

QRCodeKit是一个二维码生成工具：  
```

import com.google.zxing.*;
import com.google.zxing.common.BitMatrix;
import com.google.zxing.qrcode.decoder.ErrorCorrectionLevel;
import org.apache.commons.codec.binary.Base64;
import org.apache.commons.codec.binary.Base64OutputStream;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.util.HashMap;
import java.util.Map;

/**
 * @author kangyonggan
 * @since 10/29/18
 */
public class QRCodeKit {

    private static final String QRCODE_DEFAULT_CHARSET = "UTF-8";

    private static final int QRCODE_DEFAULT_HEIGHT = 300;

    private static final int QRCODE_DEFAULT_WIDTH = 300;

    private static final int BLACK = 0xFF000000;

    private static final int WHITE = 0xFFFFFFFF;

    public static void main(String[] args) throws IOException, NotFoundException {
        String data = "扫码看到我";
        File logoFile = new File("/xxx/logo.png");
        BufferedImage image = QRCodeKit.createQRCodeWithLogo(data, logoFile);
        ImageIO.write(image, "png", new File("/xxx/res.png"));
    }

    /**
     * Create qrcode with default settings
     *
     * @param data
     * @return
     */
    public static BufferedImage createQRCode(String data) {
        return createQRCode(data, QRCODE_DEFAULT_WIDTH, QRCODE_DEFAULT_HEIGHT);
    }

    /**
     * Create qrcode with default charset
     *
     * @param data
     * @param width
     * @param height
     * @return
     */
    public static BufferedImage createQRCode(String data, int width, int height) {
        return createQRCode(data, QRCODE_DEFAULT_CHARSET, width, height);
    }

    /**
     * Create qrcode with specified charset
     *
     * @param data
     * @param charset
     * @param width
     * @param height
     * @return
     */
    public static BufferedImage createQRCode(String data, String charset, int width, int height) {
        Map hint = new HashMap();
        hint.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);
        hint.put(EncodeHintType.CHARACTER_SET, charset);

        return createQRCode(data, charset, hint, width, height);
    }

    /**
     * Create qrcode with specified hint
     *
     * @param data
     * @param charset
     * @param hint
     * @param width
     * @param height
     * @return
     */
    public static BufferedImage createQRCode(String data, String charset, Map<EncodeHintType, ?> hint, int width,
                                             int height) {
        BitMatrix matrix;
        try {
            matrix = new MultiFormatWriter().encode(new String(data.getBytes(charset), charset), BarcodeFormat.QR_CODE,
                    width, height, hint);
            return toBufferedImage(matrix);
        } catch (WriterException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (Exception e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }

    public static BufferedImage toBufferedImage(BitMatrix matrix) {
        int width = matrix.getWidth();
        int height = matrix.getHeight();
        BufferedImage image = new BufferedImage(width, height,
                BufferedImage.TYPE_INT_RGB);
        for (int x = 0; x < width; x++) {
            for (int y = 0; y < height; y++) {
                image.setRGB(x, y, matrix.get(x, y) ? BLACK : WHITE);
            }
        }
        return image;
    }

    /**
     * Create qrcode with default settings and logo
     *
     * @param data
     * @param logoFile
     * @return
     */
    public static BufferedImage createQRCodeWithLogo(String data, File logoFile) {
        return createQRCodeWithLogo(data, QRCODE_DEFAULT_WIDTH, QRCODE_DEFAULT_HEIGHT, logoFile);
    }

    /**
     * Create qrcode with default charset and logo
     *
     * @param data
     * @param width
     * @param height
     * @param logoFile
     * @return
     */
    public static BufferedImage createQRCodeWithLogo(String data, int width, int height, File logoFile) {
        return createQRCodeWithLogo(data, QRCODE_DEFAULT_CHARSET, width, height, logoFile);
    }

    /**
     * Create qrcode with specified charset and logo
     *
     * @param data
     * @param charset
     * @param width
     * @param height
     * @param logoFile
     * @return
     */
    public static BufferedImage createQRCodeWithLogo(String data, String charset, int width, int height, File logoFile) {
        Map<EncodeHintType, Object> hint = new HashMap<>(8);
        hint.put(EncodeHintType.ERROR_CORRECTION, ErrorCorrectionLevel.H);
        hint.put(EncodeHintType.CHARACTER_SET, charset);

        return createQRCodeWithLogo(data, charset, hint, width, height, logoFile);
    }

    /**
     * Create qrcode with specified hint and logo
     *
     * @param data
     * @param charset
     * @param hint
     * @param width
     * @param height
     * @param logoFile
     * @return
     */
    public static BufferedImage createQRCodeWithLogo(String data, String charset, Map<EncodeHintType, ?> hint,
                                                     int width, int height, File logoFile) {
        try {
            BufferedImage qrcode = createQRCode(data, charset, hint, width, height);
            BufferedImage logo = ImageIO.read(logoFile);
            int deltaHeight = height - logo.getHeight();
            int deltaWidth = width - logo.getWidth();

            BufferedImage combined = new BufferedImage(height, width, BufferedImage.TYPE_INT_ARGB);
            Graphics2D g = (Graphics2D) combined.getGraphics();
            g.drawImage(qrcode, 0, 0, null);
            g.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 1f));
            g.drawImage(logo, Math.round(deltaWidth / 2), Math.round(deltaHeight / 2), null);

            return combined;
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (Exception e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }

    /**
     * Return base64 for image
     *
     * @param image
     * @return
     */
    public static String getImageBase64String(BufferedImage image) {
        String result = null;
        try {
            ByteArrayOutputStream os = new ByteArrayOutputStream();
            OutputStream b64 = new Base64OutputStream(os);
            ImageIO.write(image, "png", b64);
            result = os.toString("UTF-8");
        } catch (UnsupportedEncodingException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage(), e);
        }
        return result;
    }

    /**
     * Decode the base64Image data to image
     *
     * @param base64ImageString
     * @param file
     */
    public static void convertBase64StringToImage(String base64ImageString, File file) {
        FileOutputStream os;
        try {
            Base64 d = new Base64();
            byte[] bs = d.decode(base64ImageString);
            os = new FileOutputStream(file.getAbsolutePath());
            os.write(bs);
            os.close();
        } catch (FileNotFoundException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (IOException e) {
            throw new RuntimeException(e.getMessage(), e);
        } catch (Exception e) {
            throw new RuntimeException(e.getMessage(), e);
        }
    }


}
```


生成二维码使用的是zxing:  
```
<dependency>
    <groupId>com.google.zxing</groupId>
    <artifactId>core</artifactId>
    <version>3.3.0</version>
</dependency>
<dependency>
    <groupId>com.google.zxing</groupId>
    <artifactId>javase</artifactId>
    <version>3.3.0</version>
</dependency>
```

其他几个类，都是微信的sdk：  
- IWXPayDomain
- WXPay
- WXPayConfig
- WXPayConstants
- WXPayReport
- WXPayRequest
- WXPayUtil
- WXPayXmlUtil

sdk下载地址：[https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=11_1](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=11_1)

对应接口文档地址：[https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_1)

## 四、后台通知
当用户扫码完成支付后，微信会发起后台通知告诉我们交易成功了。

```
/**
 * 微信支付后台通知
 *
 * @param request
 * @return
 * @throws Exception
 */
@PostMapping("wxpay")
public String wxpay(HttpServletRequest request) throws Exception {
    InputStream inStream = null;
    ByteArrayOutputStream outSteam = null;
    try {
        inStream = request.getInputStream();
        outSteam = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        int len;
        while ((len = inStream.read(buffer)) != -1) {
            outSteam.write(buffer, 0, len);
        }
        String result = new String(outSteam.toByteArray(), "utf-8");
        log.info("微信支付后台通知内容:{}", result);
        WXPay wxpay = new WXPay(wxPayConfig);

        // 转换成map
        Map<String, String> notifyMap = WXPayUtil.xmlToMap(result);
        if (wxpay.isResponseSignatureValid(notifyMap)) {
            log.info("验签通过");

            String serialNo = notifyMap.get("out_trade_no");
            Command command = commandService.findCommandBySerialNo(serialNo);
            if (command == null) {
                log.info("异步通知流水号不存在:{}", serialNo);
                return "<xml><return_code><![CDATA[FAIL]]></return_code><return_msg><![CDATA[ERR]]></return_msg></xml>";
            }

            if (WXPayConstants.SUCCESS.equals(notifyMap.get("result_code"))) {
                log.info("交易成功，状态更新为待发货");

                // 更新交易状态
                command.setTranSt(TranSt.P.getCode());
                commandService.updateTranSt(command);

                // 通知商户系统发货
                if(paymentHelper.notify(command)) {
                    // 响应落库, 更新交易状态
                    wxPayTransactionService.processNotice(notifyMap, command);
                }
            }
        } else {
            log.info("验签失败");
            // 签名错误，如果数据里没有sign字段，也认为是签名错误
            return "<xml><return_code><![CDATA[FAIL]]></return_code><return_msg><![CDATA[ERR]]></return_msg></xml>";
        }
    } catch (Exception e) {
        log.error("微信支付后台通知接收异常", e);
    } finally {
        if (outSteam != null) {
            outSteam.close();
        }
        if (inStream != null) {
            inStream.close();
        }
    }

    return "<xml><return_code><![CDATA[SUCCESS]]></return_code><return_msg><![CDATA[OK]]></return_msg></xml>";
}
```

对应接口文档地址：[https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_7&index=8](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_7&index=8)

## 五、单笔查询
如果我们没收到后台通知怎么办？这时候就可以通过单笔查询主动去微信支付平台查询订单状态。

```
WXPay wxpay = new WXPay(wxPayConfig);

Map<String, String> data = new HashMap<>(4);
data.put("out_trade_no", command.getSerialNo());

Map<String, String> resp = wxpay.orderQuery(data);
String respCo = resp.get("return_code");
String respMsg = resp.get("return_msg");
String tranSt = TranSt.I.getCode();
BigDecimal amount = BigDecimal.ZERO;
String channelSerialNo = "";

log.info("微信支付查询响应码:{}", respCo);
log.info("微信支付查询响应消息:{}", respMsg);
if (WXPayConstants.SUCCESS.equals(respCo)) {
    tranSt = resp.get("trade_state");
    String errCode = resp.get("err_code");
    log.info("微信支付查询回来的交易状态：{}", tranSt);
    log.info("微信支付查询回来的errCode：{}", errCode);

    channelSerialNo = resp.get("transaction_id");
    amount = new BigDecimal(resp.getOrDefault("total_fee", "0"));
    if (amount.compareTo(BigDecimal.ZERO) > 0) {
        amount = amount.divide(BigDecimal.valueOf(100));
    }

    if (WXPayConstants.SUCCESS.equals(tranSt)) {
        tranSt = TranSt.Y.getCode();
    } else if ("ORDERNOTEXIST".equals(errCode)) {
        log.info("订单不存在");
        tranSt = TranSt.F.getCode();
    } else if ("PAYERROR".equals(tranSt)) {
        tranSt = TranSt.F.getCode();
    } else {
        tranSt = TranSt.I.getCode();
    }
}
```

对应接口文档地址：[https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_2](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_2)

## 六、下载对账单
如果我们需要日终对账，那么就要用到下载对账单接口。但是此接口不大符合我的需要，因此我没用这个接口，而是循环使用单笔查询代替的。

对应接口文档地址：[https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_6](https://pay.weixin.qq.com/wiki/doc/api/native.php?chapter=9_6)
